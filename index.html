<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Path.io â€“ Advanced Tracker</title>

<script src="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.js"></script>
<link href="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.css" rel="stylesheet"/>

<style>
body { margin:0; font-family:Arial,sans-serif; }
#map { position:absolute; inset:0; }

#info {
    position:absolute;
    top:10px; left:10px;
    background:white;
    padding:12px;
    border-radius:8px;
    box-shadow:0 2px 6px rgba(0,0,0,.25);
    z-index:2;
    width:280px;
    font-size:14px;
}

#info h3 { margin:0 0 8px; }

.stat { margin:4px 0; }

button {
    margin-top:6px;
    width:100%;
    padding:6px;
    cursor:pointer;
}
</style>
</head>
<body>

<div id="info">
    <h3>Path.io Tracker</h3>
    <div id="status">Waiting for permissionâ€¦</div>
    <div class="stat" id="time">â± Time: 0s</div>
    <div class="stat" id="distance">ğŸ“ Distance: 0 m</div>
    <div class="stat" id="speed">ğŸš€ Speed: 0 km/h</div>
    <div class="stat" id="heading">ğŸ§­ Heading: â€“</div>
    <button id="toggle">Pause Tracking</button>
</div>

<div id="map"></div>

<script>
const map = new maplibregl.Map({
    container: 'map',
    style: {
        version:8,
        sources:{
            osm:{
                type:'raster',
                tiles:[
                    'https://a.tile.openstreetmap.org/{z}/{x}/{y}.png',
                    'https://b.tile.openstreetmap.org/{z}/{x}/{y}.png',
                    'https://c.tile.openstreetmap.org/{z}/{x}/{y}.png'
                ],
                tileSize:256
            }
        },
        layers:[{ id:'osm', type:'raster', source:'osm' }]
    },
    center:[0,0],
    zoom:2
});

map.addControl(new maplibregl.NavigationControl(), 'top-right');

let path = [];
let watchId = null;
let marker = null;
let accuracyCircle = null;
let tracking = true;

let startTime = Date.now();
let totalDistance = 0;
let lastPoint = null;

map.on('load', () => {
    map.addSource('path', {
        type:'geojson',
        data:{ type:'Feature', geometry:{ type:'LineString', coordinates:[] } }
    });

    map.addLayer({
        id:'path-line',
        type:'line',
        source:'path',
        paint:{
            'line-color':'#1976d2',
            'line-width':4
        }
    });

    startTracking();
});

function haversine(a, b) {
    const R = 6371000;
    const toRad = d => d * Math.PI / 180;
    const dLat = toRad(b.lat - a.lat);
    const dLon = toRad(b.lon - a.lon);

    const h =
        Math.sin(dLat/2)**2 +
        Math.cos(toRad(a.lat)) *
        Math.cos(toRad(b.lat)) *
        Math.sin(dLon/2)**2;

    return 2 * R * Math.asin(Math.sqrt(h));
}

function startTracking() {
    if (!navigator.geolocation) {
        status('Geolocation unsupported');
        return;
    }

    watchId = navigator.geolocation.watchPosition(pos => {
        if (!tracking) return;

        const { latitude, longitude, accuracy, heading, speed } = pos.coords;

        const current = { lat: latitude, lon: longitude };

        if (lastPoint) {
            const d = haversine(lastPoint, current);

            // GPS noise filter (ignore jumps > 50m)
            if (d < 50) {
                totalDistance += d;
                path.push([longitude, latitude]);
            }
        } else {
            path.push([longitude, latitude]);
        }

        lastPoint = current;

        map.getSource('path').setData({
            type:'Feature',
            geometry:{ type:'LineString', coordinates:path }
        });

        if (!marker) {
            marker = new maplibregl.Marker().setLngLat([longitude, latitude]).addTo(map);
            map.flyTo({ center:[longitude, latitude], zoom:16 });
        } else {
            marker.setLngLat([longitude, latitude]);
        }

        updateAccuracyCircle(longitude, latitude, accuracy);

        updateStats(speed, heading);

    }, err => status(err.message), {
        enableHighAccuracy:true,
        maximumAge:0
    });
}

function updateAccuracyCircle(lon, lat, accuracy) {
    const circle = turf.circle([lon, lat], accuracy / 1000, { steps:32 });

    if (!map.getSource('accuracy')) {
        map.addSource('accuracy', { type:'geojson', data:circle });
        map.addLayer({
            id:'accuracy-fill',
            type:'fill',
            source:'accuracy',
            paint:{ 'fill-color':'#1976d2', 'fill-opacity':0.15 }
        });
    } else {
        map.getSource('accuracy').setData(circle);
    }
}

function updateStats(speed, heading) {
    const elapsed = Math.floor((Date.now() - startTime) / 1000);

    document.getElementById('time').textContent =
        `â± Time: ${elapsed}s`;

    document.getElementById('distance').textContent =
        `ğŸ“ Distance: ${totalDistance.toFixed(1)} m`;

    document.getElementById('speed').textContent =
        `ğŸš€ Speed: ${speed ? (speed * 3.6).toFixed(1) : 0} km/h`;

    document.getElementById('heading').textContent =
        `ğŸ§­ Heading: ${heading !== null ? Math.round(heading) + 'Â°' : 'â€“'}`;

    status('Tracking active');
}

function status(msg) {
    document.getElementById('status').textContent = msg;
}

document.getElementById('toggle').onclick = () => {
    tracking = !tracking;
    document.getElementById('toggle').textContent =
        tracking ? 'Pause Tracking' : 'Resume Tracking';
};
</script>

<!-- Turf for accuracy circle math -->
<script src="https://unpkg.com/@turf/turf@6/turf.min.js"></script>

</body>
</html>